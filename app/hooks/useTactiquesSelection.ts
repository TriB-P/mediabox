// app/hooks/useTactiquesSelection.ts - Version corrig√©e avec nettoyage complet

import { useState, useCallback } from 'react';
import { useClient } from '../contexts/ClientContext';
import { useSelection } from '../contexts/SelectionContext';
import { duplicateSelectedItems, DuplicationContext } from '../lib/duplicationService';

// ==================== TYPES ====================

interface UseTactiquesSelectionProps {
  sections: any[];
  tactiques: { [sectionId: string]: any[] };
  placements: { [tactiqueId: string]: any[] };
  creatifs: { [placementId: string]: any[] };
  onRefresh: (() => Promise<void>) | (() => void);
  onDeleteSection?: (sectionId: string) => Promise<void>;
  onDeleteTactique?: (sectionId: string, tactiqueId: string) => Promise<void>;
  onDeletePlacement?: (sectionId: string, tactiqueId: string, placementId: string) => Promise<void>;
  onDeleteCreatif?: (sectionId: string, tactiqueId: string, placementId: string, creatifId: string) => Promise<void>;
  // üî• AJOUT: Callback pour forcer la r√©initialisation compl√®te
  onForceSelectionReset?: () => void;
}

interface UseTactiquesSelectionReturn {
  selectedItems: Set<string>;
  duplicationLoading: boolean;
  deletionLoading: boolean;
  handleSelectItems: (
    itemIds: string[],
    type: 'section' | 'tactique' | 'placement' | 'creatif',
    isSelected: boolean
  ) => void;
  handleClearSelection: () => void;
  handleDuplicateSelected: (itemIds: string[]) => Promise<void>;
  handleDeleteSelected: (itemIds: string[]) => Promise<void>;
  selectedItemsWithData: Array<{
    id: string;
    name: string;
    type: 'section' | 'tactique' | 'placement' | 'creatif';
    data?: any;
  }>;
}

// ==================== TYPES POUR LA SUPPRESSION ====================

interface ItemToDelete {
  id: string;
  type: 'section' | 'tactique' | 'placement' | 'creatif';
  sectionId: string;
  tactiqueId?: string;
  placementId?: string;
  name: string;
}

// ==================== HOOK PRINCIPAL ====================

export function useTactiquesSelection({
  sections,
  tactiques,
  placements,
  creatifs,
  onRefresh,
  onDeleteSection,
  onDeleteTactique,
  onDeletePlacement,
  onDeleteCreatif,
  onForceSelectionReset // üî• AJOUT
}: UseTactiquesSelectionProps): UseTactiquesSelectionReturn {

  const { selectedClient } = useClient();
  const { selectedCampaignId, selectedVersionId, selectedOngletId } = useSelection();

  // ==================== √âTATS ====================
  
  const [selectedItems, setSelectedItems] = useState<Set<string>>(new Set());
  const [duplicationLoading, setDuplicationLoading] = useState(false);
  const [deletionLoading, setDeletionLoading] = useState(false);

  // ==================== GESTION DES S√âLECTIONS ====================

  const handleSelectItems = useCallback((
    itemIds: string[],
    type: 'section' | 'tactique' | 'placement' | 'creatif',
    isSelected: boolean
  ) => {
    setSelectedItems(prevSelected => {
      const newSelected = new Set(prevSelected);
      itemIds.forEach(id => {
        if (isSelected) {
          newSelected.add(id);
        } else {
          newSelected.delete(id);
        }
      });
      return newSelected;
    });
  }, []);

  // üî• CORRECTION: Nettoyage complet avec r√©initialisation forc√©e
  const handleClearSelection = useCallback(() => {
    console.log('üßπ Nettoyage complet de la s√©lection');
    
    // Nettoyer l'√©tat local
    setSelectedItems(new Set());
    
    // üî• NOUVEAU: Forcer la r√©initialisation de tous les hooks d√©pendants
    if (onForceSelectionReset) {
      console.log('üîÑ Force reset de la logique de s√©lection');
      onForceSelectionReset();
    }
  }, [onForceSelectionReset]);

  // ==================== FONCTION DE NOTIFICATION ====================

  const showNotification = useCallback((message: string, type: 'success' | 'error' = 'success') => {
    const toast = document.createElement('div');
    toast.className = `fixed top-4 right-4 ${
      type === 'success' ? 'bg-green-500' : 'bg-red-500'
    } text-white px-4 py-2 rounded shadow-lg z-50 text-sm`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      if (document.body.contains(toast)) {
        document.body.removeChild(toast);
      }
    }, type === 'success' ? 2000 : 3000);
  }, []);

  // ==================== FONCTION DE RECHERCHE D'√âL√âMENTS ====================

  const findItemHierarchy = useCallback((itemId: string): ItemToDelete | null => {
    // Chercher dans les sections
    for (const section of sections) {
      if (section.id === itemId) {
        return {
          id: itemId,
          type: 'section',
          sectionId: section.id,
          name: section.SECTION_Name
        };
      }
      
      // Chercher dans les tactiques
      for (const tactique of (tactiques[section.id] || [])) {
        if (tactique.id === itemId) {
          return {
            id: itemId,
            type: 'tactique',
            sectionId: section.id,
            tactiqueId: tactique.id,
            name: tactique.TC_Label
          };
        }
        
        // Chercher dans les placements
        for (const placement of (placements[tactique.id] || [])) {
          if (placement.id === itemId) {
            return {
              id: itemId,
              type: 'placement',
              sectionId: section.id,
              tactiqueId: tactique.id,
              placementId: placement.id,
              name: placement.PL_Label
            };
          }
          
          // Chercher dans les cr√©atifs
          for (const creatif of (creatifs[placement.id] || [])) {
            if (creatif.id === itemId) {
              return {
                id: itemId,
                type: 'creatif',
                sectionId: section.id,
                tactiqueId: tactique.id,
                placementId: placement.id,
                name: creatif.CR_Label
              };
            }
          }
        }
      }
    }
    
    return null;
  }, [sections, tactiques, placements, creatifs]);

  // ==================== SUPPRESSION GROUP√âE ====================

  const handleDeleteSelected = useCallback(async (itemIds: string[]) => {
    if (itemIds.length === 0) {
      return;
    }

    // V√©rifier que les fonctions de suppression sont disponibles
    if (!onDeleteSection || !onDeleteTactique || !onDeletePlacement || !onDeleteCreatif) {
      console.error('‚ùå Fonctions de suppression non disponibles');
      showNotification('‚ùå Fonctions de suppression non configur√©es', 'error');
      return;
    }

    // Construire la liste des √©l√©ments √† supprimer avec leur hi√©rarchie
    const itemsToDelete: ItemToDelete[] = [];
    
    for (const itemId of itemIds) {
      const hierarchy = findItemHierarchy(itemId);
      if (hierarchy) {
        itemsToDelete.push(hierarchy);
      } else {
        console.warn('‚ö†Ô∏è √âl√©ment non trouv√© dans la hi√©rarchie:', itemId);
      }
    }

    if (itemsToDelete.length === 0) {
      console.warn('‚ö†Ô∏è Aucun √©l√©ment valide √† supprimer');
      return;
    }

    // Confirmation utilisateur
    const itemsDescription = itemsToDelete.map(item => `${item.name} (${item.type})`).join(', ');
    const confirmMessage = `√ätes-vous s√ªr de vouloir supprimer les ${itemsToDelete.length} √©l√©ments s√©lectionn√©s ?\n\n${itemsDescription}\n\n‚ö†Ô∏è Cette action est irr√©versible et supprimera √©galement tous les √©l√©ments enfants.`;
    
    if (!confirm(confirmMessage)) {
      return;
    }

    console.log('üóëÔ∏è D√©but suppression group√©e:', itemsToDelete);

    try {
      setDeletionLoading(true);

      // Organisation par ordre de suppression (enfants d'abord)
      const creatifItems = itemsToDelete.filter(item => item.type === 'creatif');
      const placementItems = itemsToDelete.filter(item => item.type === 'placement');
      const tactiqueItems = itemsToDelete.filter(item => item.type === 'tactique');
      const sectionItems = itemsToDelete.filter(item => item.type === 'section');

      let successCount = 0;
      let errorCount = 0;
      const errors: string[] = [];

      // 1. Supprimer les cr√©atifs
      for (const item of creatifItems) {
        try {
          await onDeleteCreatif(item.sectionId, item.tactiqueId!, item.placementId!, item.id);
          successCount++;
          console.log('‚úÖ Cr√©atif supprim√©:', item.name);
        } catch (error) {
          errorCount++;
          const errorMsg = `Erreur suppression cr√©atif "${item.name}"`;
          errors.push(errorMsg);
          console.error('‚ùå', errorMsg, error);
        }
      }

      // 2. Supprimer les placements
      for (const item of placementItems) {
        try {
          await onDeletePlacement(item.sectionId, item.tactiqueId!, item.id);
          successCount++;
          console.log('‚úÖ Placement supprim√©:', item.name);
        } catch (error) {
          errorCount++;
          const errorMsg = `Erreur suppression placement "${item.name}"`;
          errors.push(errorMsg);
          console.error('‚ùå', errorMsg, error);
        }
      }

      // 3. Supprimer les tactiques
      for (const item of tactiqueItems) {
        try {
          await onDeleteTactique(item.sectionId, item.id);
          successCount++;
          console.log('‚úÖ Tactique supprim√©e:', item.name);
        } catch (error) {
          errorCount++;
          const errorMsg = `Erreur suppression tactique "${item.name}"`;
          errors.push(errorMsg);
          console.error('‚ùå', errorMsg, error);
        }
      }

      // 4. Supprimer les sections
      for (const item of sectionItems) {
        try {
          await onDeleteSection(item.id);
          successCount++;
          console.log('‚úÖ Section supprim√©e:', item.name);
        } catch (error) {
          errorCount++;
          const errorMsg = `Erreur suppression section "${item.name}"`;
          errors.push(errorMsg);
          console.error('‚ùå', errorMsg, error);
        }
      }

      // R√©sultats
      if (successCount > 0) {
        const successMessage = `‚úÖ ${successCount} √©l√©ment${successCount > 1 ? 's supprim√©s' : ' supprim√©'} avec succ√®s`;
        showNotification(successMessage);
      }

      if (errorCount > 0) {
        const errorMessage = `‚ùå ${errorCount} erreur${errorCount > 1 ? 's' : ''} lors de la suppression`;
        showNotification(errorMessage, 'error');
        console.error('‚ùå Erreurs de suppression:', errors);
      }

      // üî• CORRECTION: Nettoyage complet AVANT le refresh
      console.log('üßπ Nettoyage complet apr√®s suppression');
      handleClearSelection();
      
      // Attendre un petit d√©lai pour s'assurer que le nettoyage est effectif
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Puis rafra√Æchir
      await Promise.resolve(onRefresh());

    } catch (error) {
      console.error('üí• Erreur critique lors de la suppression group√©e:', error);
      showNotification('‚ùå Erreur critique lors de la suppression', 'error');
      
      // üî• CORRECTION: Nettoyer m√™me en cas d'erreur
      handleClearSelection();
    } finally {
      setDeletionLoading(false);
    }
  }, [
    findItemHierarchy,
    onDeleteSection,
    onDeleteTactique, 
    onDeletePlacement,
    onDeleteCreatif,
    handleClearSelection,
    onRefresh,
    showNotification
  ]);

  // ==================== DUPLICATION (INCHANG√âE) ====================

  const handleDuplicateSelected = useCallback(async (itemIds: string[]) => {
    if (!selectedClient?.clientId || !selectedCampaignId || !selectedVersionId || !selectedOngletId) {
      console.error('Contexte manquant pour la duplication');
      showNotification('‚ùå Contexte manquant pour la duplication', 'error');
      return;
    }

    if (itemIds.length === 0) {
      return;
    }

    console.log('üîÑ D√©but duplication de', itemIds.length, '√©l√©ments:', itemIds);

    try {
      setDuplicationLoading(true);

      const context: DuplicationContext = {
        clientId: selectedClient.clientId,
        campaignId: selectedCampaignId,
        versionId: selectedVersionId,
        ongletId: selectedOngletId
      };

      const itemHierarchy = {
        sections,
        tactiques,
        placements,
        creatifs
      };

      const result = await duplicateSelectedItems(context, itemIds, itemHierarchy);

      if (result.success && result.duplicatedIds.length > 0) {
        console.log('‚úÖ Duplication r√©ussie:', result.duplicatedIds);
        
        const successMessage = `‚úÖ ${result.duplicatedIds.length} √©l√©ment${
          result.duplicatedIds.length > 1 ? 's dupliqu√©s' : ' dupliqu√©'
        } avec succ√®s`;
        
        showNotification(successMessage);

        await Promise.resolve(onRefresh());
        handleClearSelection();

      } else {
        const errorMessages = result.errors.length > 0 ? result.errors : ['Erreur inconnue lors de la duplication'];
        console.error('‚ùå Erreurs duplication:', errorMessages);
        showNotification(`‚ùå Erreur duplication: ${errorMessages[0]}`, 'error');
      }

    } catch (error) {
      console.error('üí• Erreur critique duplication:', error);
      showNotification('‚ùå Erreur critique lors de la duplication', 'error');
    } finally {
      setDuplicationLoading(false);
    }
  }, [
    selectedClient?.clientId,
    selectedCampaignId,
    selectedVersionId,
    selectedOngletId,
    sections,
    tactiques,
    placements,
    creatifs,
    onRefresh,
    handleClearSelection,
    showNotification
  ]);

  // ==================== DONN√âES ENRICHIES POUR LES √âL√âMENTS S√âLECTIONN√âS ====================

  const selectedItemsWithData = useCallback(() => {
    const result: Array<{
      id: string;
      name: string;
      type: 'section' | 'tactique' | 'placement' | 'creatif';
      data?: any;
    }> = [];

    Array.from(selectedItems).forEach(itemId => {
      const hierarchy = findItemHierarchy(itemId);
      if (hierarchy) {
        result.push({
          id: hierarchy.id,
          name: hierarchy.name,
          type: hierarchy.type,
          data: null
        });
      }
    });

    return result;
  }, [selectedItems, findItemHierarchy]);

  // ==================== RETURN ====================

  return {
    selectedItems,
    duplicationLoading,
    deletionLoading,
    handleSelectItems,
    handleClearSelection,
    handleDuplicateSelected,
    handleDeleteSelected,
    selectedItemsWithData: selectedItemsWithData()
  };
}